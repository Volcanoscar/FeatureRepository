From 2ce411e66eb2a999fe44f77af8e6683bc78acb74 Mon Sep 17 00:00:00 2001
From: liubinyang <liubinyang@hkzechin.com>
Date: Tue, 28 Jun 2016 16:09:05 +0800
Subject: [PATCH] =?UTF-8?q?[Bmobile][SIMLOCK]=E5=A2=9E=E5=8A=A0Bmobile?=
 =?UTF-8?q?=E9=94=81=E7=BD=91=E9=9C=80=E6=B1=82=EF=BC=8C=E6=89=8B=E5=8A=A8?=
 =?UTF-8?q?=E4=B8=8A=E9=94=81=E7=A0=81*#26872016*#=EF=BC=8C=E8=A7=A3?=
 =?UTF-8?q?=E9=94=81=E7=A0=81IMEI=E5=89=8D14=E4=BD=8D=EF=BC=8C=E4=BB=8E?=
 =?UTF-8?q?=E7=AC=AC=E4=B8=80=E4=BD=8D=E8=B5=B7=EF=BC=8C=E6=AF=8F=E7=9B=B8?=
 =?UTF-8?q?=E9=82=BB=E4=B8=A4=E4=BD=8D=E7=9B=B8=E5=8A=A0=E6=A8=A1=E4=BB=A5?=
 =?UTF-8?q?10=E4=B8=BA=E4=B8=80=E4=BD=8D=EF=BC=8C=E5=8F=96IMEI=E7=AC=AC15?=
 =?UTF-8?q?=E4=BD=8D=E5=81=9A=E4=B8=BA=E7=AC=AC8=E4=BD=8D=EF=BC=8C?=
 =?UTF-8?q?=E7=94=9F=E6=88=90=E8=A7=A3=E9=94=81=E7=A0=81?=
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

---
 .../base/packages/Keyguard/AndroidManifest.xml     |   5 +-
 .../android/keyguard/KeyguardSecurityModel.java    |   8 +
 .../android/keyguard/KeyguardUpdateMonitor.java    |  97 +++++++-
 .../src/com/android/keyguard/NvRAMAgent.java       | 271 +++++++++++++++++++++
 .../Telephony/KeyguardSimPinPukMeView.java         | 227 ++++++++++++++++-
 .../mediatek/keyguard/Telephony/NvRAMAgent.java    | 271 +++++++++++++++++++++
 .../base/packages/SystemUI/AndroidManifest.xml     |   2 +-
 .../systemui/keyguard/KeyguardViewMediator.java    |  10 +-
 alps/packages/apps/Dialer/Android.mk               |   1 +
 alps/packages/apps/Dialer/AndroidManifest.xml      |   3 +-
 alps/packages/apps/Dialer/res/values/strings.xml   |   5 +
 .../Dialer/src/com/android/dialer/NvRAMAgent.java  | 271 +++++++++++++++++++++
 .../src/com/android/dialer/ZechinEngineerCode.java | 169 +++++++++++++
 alps/packages/apps/Settings/AndroidManifest.xml    |   1 +
 .../src/com/mediatek/settings/NvRAMAgent.java      | 271 +++++++++++++++++++++
 .../mediatek/settings/RestoreRotationReceiver.java |  74 ++++++
 16 files changed, 1678 insertions(+), 8 deletions(-)
 mode change 100644 => 100755 alps/frameworks/base/packages/Keyguard/AndroidManifest.xml
 mode change 100644 => 100755 alps/frameworks/base/packages/Keyguard/src/com/android/keyguard/KeyguardSecurityModel.java
 mode change 100644 => 100755 alps/frameworks/base/packages/Keyguard/src/com/android/keyguard/KeyguardUpdateMonitor.java
 create mode 100755 alps/frameworks/base/packages/Keyguard/src/com/android/keyguard/NvRAMAgent.java
 create mode 100755 alps/frameworks/base/packages/Keyguard/src/com/mediatek/keyguard/Telephony/NvRAMAgent.java
 mode change 100644 => 100755 alps/frameworks/base/packages/SystemUI/AndroidManifest.xml
 mode change 100644 => 100755 alps/frameworks/base/packages/SystemUI/src/com/android/systemui/keyguard/KeyguardViewMediator.java
 mode change 100644 => 100755 alps/packages/apps/Dialer/Android.mk
 create mode 100755 alps/packages/apps/Dialer/src/com/android/dialer/NvRAMAgent.java
 mode change 100644 => 100755 alps/packages/apps/Settings/AndroidManifest.xml
 create mode 100755 alps/packages/apps/Settings/src/com/mediatek/settings/NvRAMAgent.java

diff --git a/alps/frameworks/base/packages/Keyguard/AndroidManifest.xml b/alps/frameworks/base/packages/Keyguard/AndroidManifest.xml
old mode 100644
new mode 100755
index aca0b8e..9b5dda1
--- a/alps/frameworks/base/packages/Keyguard/AndroidManifest.xml
+++ b/alps/frameworks/base/packages/Keyguard/AndroidManifest.xml
@@ -18,8 +18,9 @@
 -->
 <manifest xmlns:android="http://schemas.android.com/apk/res/android"
     package="com.android.keyguard"
-    android:sharedUserId="android.uid.systemui"
-    coreApp="true">
+    coreApp="true"
+    android:sharedUserId="android.uid.system">
+    
     <uses-sdk android:minSdkVersion="10" android:targetSdkVersion="17"/>
     <uses-permission android:name="android.permission.VIBRATE" />
     <uses-permission android:name="android.permission.MODIFY_PHONE_STATE" />
diff --git a/alps/frameworks/base/packages/Keyguard/src/com/android/keyguard/KeyguardSecurityModel.java b/alps/frameworks/base/packages/Keyguard/src/com/android/keyguard/KeyguardSecurityModel.java
old mode 100644
new mode 100755
index 2a7d184..a9e061f
--- a/alps/frameworks/base/packages/Keyguard/src/com/android/keyguard/KeyguardSecurityModel.java
+++ b/alps/frameworks/base/packages/Keyguard/src/com/android/keyguard/KeyguardSecurityModel.java
@@ -82,6 +82,14 @@ public class KeyguardSecurityModel {
         KeyguardUpdateMonitor monitor = KeyguardUpdateMonitor.getInstance(mContext);
 
         SecurityMode mode = SecurityMode.None;
+		
+        //jianqiu add for sim lock 
+        Log.d("simlock","getSecurityMode = " + KeyguardUpdateMonitor.SHOWLOCKSIM) ;
+        if(KeyguardUpdateMonitor.SHOWLOCKSIM){
+        	mode = SecurityMode.SimPinPukMe1;
+		return mode;
+        }
+	    //jianqiu add end
 
         if (PowerOffAlarmManager.isAlarmBoot()) { /// M: add for power-off alarm
             mode = SecurityMode.AlarmBoot;
diff --git a/alps/frameworks/base/packages/Keyguard/src/com/android/keyguard/KeyguardUpdateMonitor.java b/alps/frameworks/base/packages/Keyguard/src/com/android/keyguard/KeyguardUpdateMonitor.java
old mode 100644
new mode 100755
index f3d31e4..44cf7ac
--- a/alps/frameworks/base/packages/Keyguard/src/com/android/keyguard/KeyguardUpdateMonitor.java
+++ b/alps/frameworks/base/packages/Keyguard/src/com/android/keyguard/KeyguardUpdateMonitor.java
@@ -89,6 +89,8 @@ import static android.os.BatteryManager.EXTRA_LEVEL;
 import static android.os.BatteryManager.EXTRA_PLUGGED;
 import static android.os.BatteryManager.EXTRA_STATUS;
 
+import android.os.IBinder; //jianqiu add 20150424
+
 /**
  * Watches for updates that may be interesting to the keyguard, and provides
  * the up to date information as well as a registration for callbacks that care
@@ -222,6 +224,9 @@ public class KeyguardUpdateMonitor implements TrustManager.TrustListener {
     private TrustManager mTrustManager;
     private int mFingerprintRunningState = FINGERPRINT_STATE_STOPPED;
 
+   public static boolean SHOWLOCKSIM = false;//jianqiu add 20150424
+   public static boolean LOCKREBOOTFLAG = true;//@darren add for reboot flag	
+
     // M: modify for mock
     @VisibleForTesting
     final Handler mHandler = new Handler() {
@@ -781,7 +786,13 @@ public class KeyguardUpdateMonitor implements TrustManager.TrustListener {
             //if (KeyguardUtils.isMediatekSimMeLockSupport()) {
             /// M: to create new thread to query SIM ME lock status
             /// after finish query, send MSG_SIM_STATE_CHANGE message
-            new simMeStatusQueryThread(simArgs).start();
+            //new simMeStatusQueryThread(simArgs).start();
+ 	    	if( readData() == 1 ){//unlock
+            	new simMeCheckThread(simArgs.subId, "12345678").start();//12345678: this password is set in modem
+            } else {
+                new simMeStatusQueryThread(simArgs).start();
+            }
+	    //End add                
         } else {
             mHandler.sendMessage(mHandler.obtainMessage(MSG_SIM_STATE_CHANGE, simArgs));
         }
@@ -859,6 +870,80 @@ public class KeyguardUpdateMonitor implements TrustManager.TrustListener {
     private CancellationSignal mFingerprintCancelSignal;
     private FingerprintManager mFpm;
 
+
+    //jianqiu add 20150423 for SIM_ME_LOCK
+    private class simMeCheckThread extends Thread {
+        int mSubId;
+        String mPasswd;
+         private int mResult;
+
+        simMeCheckThread(int mSubId, String mPasswd) {
+            this.mSubId = mSubId;
+            this.mPasswd = mPasswd;
+        }
+
+        @Override
+        public void run() {
+            try {
+                Log.d(TAG, "simMeCheckThread-run() mSimId =" + mSubId +" mPasswd ="+mPasswd);
+                //mResult = ITelephonyEx.Stub.asInterface(ServiceManager.checkService("phoneEx")).supplyNetworkDepersonalization(
+                        //mPasswd, mSimId);
+                mResult = ITelephonyEx.Stub.asInterface(ServiceManager.getService("phoneEx"))
+                        .supplyNetworkDepersonalization(mSubId,mPasswd);
+				
+                Log.d(TAG, "simMeCheckThread-run()done mResult =" + mResult);
+
+            } catch (Exception e) {
+                Log.e(TAG, "supplyNetworkDepersonalization got exception: " + e.getMessage());
+            }
+        }
+    }
+    //End add
+
+    
+ /// The previous lines are provided and maintained by Mediatek Inc.
+   // private static final int file_lid=36;            //AP_CFG_REEB_PRODUCT_INFO_LID=36
+    private static final int file_lid_index=1023;    //Use for salestrack
+    public  static final byte file_lid_success=0x3c; //Use for salestrack
+    public  static final byte file_lid_redo=0x43;    //Use for salestrack
+    public static void writeData(byte data) {
+	//xjc change here read by filename	
+	 final String LOCK_ADDRESS_FILENAME = "/data/nvram/APCFG/APRDEB/PRODUCT_INFO";
+   try {	 
+        IBinder binder = ServiceManager.getService("NvRAMAgent");
+        NvRAMAgent agent = NvRAMAgent.Stub.asInterface(binder);
+        byte[] buff = agent.readFileByName(LOCK_ADDRESS_FILENAME);
+     
+         //   buff = agent .readFile(file_lid);// read buffer from nvram
+            buff[file_lid_index] = data;
+            if (agent.writeFileByName(LOCK_ADDRESS_FILENAME, buff) > 0) {
+                Log.d(TAG, "write success addr = " + data);
+            } else {
+                Log.d(TAG, "write failed addr = " + buff[file_lid_index]);
+            }
+        } catch (RemoteException e) {
+            // TODO Auto-generated catch block
+            e.printStackTrace();
+        }
+    }
+
+    public static byte readData() {
+	 final String LOCK_ADDRESS_FILENAME = "/data/nvram/APCFG/APRDEB/PRODUCT_INFO"; 	        
+	 try { 
+	 	IBinder binder = ServiceManager.getService("NvRAMAgent");
+        	NvRAMAgent agent = NvRAMAgent.Stub.asInterface(binder);
+        	 byte[] buff = agent.readFileByName(LOCK_ADDRESS_FILENAME);
+         	 Log.d(TAG, "read success addr = " + buff[file_lid_index]);
+            return buff[file_lid_index];
+        } catch (RemoteException e) {
+            // TODO Auto-generated catch block
+            e.printStackTrace();
+        }
+        Log.d(TAG, "read failed return -1");
+        return -1;
+    }
+
+
     /**
      * When we receive a
      * {@link com.android.internal.telephony.TelephonyIntents#ACTION_SIM_STATE_CHANGED} broadcast,
@@ -2252,6 +2337,16 @@ public class KeyguardUpdateMonitor implements TrustManager.TrustListener {
         }
     }
 
+/*jianqiu add 20150424 for sim lock*/
+    public void setSimMeLockFlag() {
+                setPinPukMeDismissFlagOfPhoneId(KeyguardUtils.getPhoneIdUsingSubId(0),true);  //xjc sing here
+		//if(( mSimStateOfPhoneId.get(0) == IccCardConstants.State.ABSENT) && (readData() != 0) )
+		if (LOCKREBOOTFLAG && readData() != 1) //@darren add for reboot flag	
+		{
+			SHOWLOCKSIM = true;
+		}
+    }
+
     /**
      ** M: Used to get specified sim card's pin or puk dismiss flag.
      * @param phoneId the id of the phone to get dismiss flag
diff --git a/alps/frameworks/base/packages/Keyguard/src/com/android/keyguard/NvRAMAgent.java b/alps/frameworks/base/packages/Keyguard/src/com/android/keyguard/NvRAMAgent.java
new file mode 100755
index 0000000..62a49a2
--- /dev/null
+++ b/alps/frameworks/base/packages/Keyguard/src/com/android/keyguard/NvRAMAgent.java
@@ -0,0 +1,271 @@
+/* Copyright Statement:
+ *
+ * This software/firmware and related documentation ("MediaTek Software") are
+ * protected under relevant copyright laws. The information contained herein is
+ * confidential and proprietary to MediaTek Inc. and/or its licensors. Without
+ * the prior written permission of MediaTek inc. and/or its licensors, any
+ * reproduction, modification, use or disclosure of MediaTek Software, and
+ * information contained herein, in whole or in part, shall be strictly
+ * prohibited.
+ *
+ * MediaTek Inc. (C) 2010. All rights reserved.
+ *
+ * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+ * THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+ * RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO RECEIVER
+ * ON AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL
+ * WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR
+ * NONINFRINGEMENT. NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH
+ * RESPECT TO THE SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY,
+ * INCORPORATED IN, OR SUPPLIED WITH THE MEDIATEK SOFTWARE, AND RECEIVER AGREES
+ * TO LOOK ONLY TO SUCH THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO.
+ * RECEIVER EXPRESSLY ACKNOWLEDGES THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO
+ * OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES CONTAINED IN MEDIATEK
+ * SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE
+ * RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
+ * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S
+ * ENTIRE AND CUMULATIVE LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE
+ * RELEASED HEREUNDER WILL BE, AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE
+ * MEDIATEK SOFTWARE AT ISSUE, OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE
+ * CHARGE PAID BY RECEIVER TO MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+ *
+ * The following software/firmware and/or related documentation ("MediaTek
+ * Software") have been modified by MediaTek Inc. All revisions are subject to
+ * any receiver's applicable license agreements with MediaTek Inc.
+ */
+
+/*
+ * This file is auto-generated.  DO NOT MODIFY.
+ * Original file: NvRAMAgent.aidl
+ */
+
+//package com.android.internal.policy.impl.keyguard;
+package com.android.keyguard;
+
+
+import java.lang.String;
+import android.os.RemoteException;
+import android.os.IBinder;
+import android.os.IInterface;
+import android.os.Binder;
+import android.os.Parcel;
+public interface NvRAMAgent extends android.os.IInterface
+{
+	/** Local-side IPC implementation stub class. */
+	public static abstract class Stub extends android.os.Binder implements NvRAMAgent
+	{
+		private static final java.lang.String DESCRIPTOR = "NvRAMAgent";
+		/** Construct the stub at attach it to the interface. */
+		public Stub()
+		{
+			this.attachInterface(this, DESCRIPTOR);
+		}
+		/**
+		 * Cast an IBinder object into an NvRAMAgent interface,
+		 * generating a proxy if needed.
+		 */
+		 
+		public static NvRAMAgent asInterface(android.os.IBinder obj)
+		{
+			if ((obj==null)) {
+				return null;
+			}
+			
+			android.os.IInterface iin = (android.os.IInterface)obj.queryLocalInterface(DESCRIPTOR);
+			if (((iin!=null)&&(iin instanceof NvRAMAgent))) {
+				return ((NvRAMAgent)iin);
+			}
+			
+			return new NvRAMAgent.Stub.Proxy(obj);
+		}
+		
+		public android.os.IBinder asBinder()
+		{
+			return this;
+		}
+		public boolean onTransact(int code, android.os.Parcel data, android.os.Parcel reply, int flags) throws android.os.RemoteException
+		{
+			switch (code)
+			{
+				case INTERFACE_TRANSACTION:
+				{
+					reply.writeString(DESCRIPTOR);
+					return true;
+				}
+				case TRANSACTION_readFile:
+				{
+					data.enforceInterface(DESCRIPTOR);
+					int _arg0;
+					_arg0 = data.readInt();
+					byte[] _result = this.readFile(_arg0);
+					reply.writeNoException();
+					reply.writeByteArray(_result);
+					return true;
+				}
+				case TRANSACTION_writeFile:
+				{
+					data.enforceInterface(DESCRIPTOR);
+					int _arg0;
+					_arg0 = data.readInt();
+					byte[] _arg1;
+					_arg1 = data.createByteArray();
+					int _result = this.writeFile(_arg0, _arg1);
+					reply.writeNoException();
+					reply.writeInt(_result);
+					return true;
+				}
+				case TRANSACTION_readFileByName:
+				{
+					data.enforceInterface(DESCRIPTOR);
+					System.out.println("NVRAM TRANSACTION_readFile="+data.readString());
+					String _arg0;
+					_arg0 = data.readString();
+					byte[] _result = this.readFileByName(_arg0);
+					reply.writeNoException();
+					reply.writeByteArray(_result);
+					return true;
+				}
+				
+				case TRANSACTION_writeFileByName:
+				{
+					data.enforceInterface(DESCRIPTOR);
+						String _arg0;
+					_arg0 = data.readString();
+					
+					
+					System.out.println("NVRAM TRANSACTION_writeFile="+data.readString());
+					byte[] _arg1;
+					_arg1 = data.createByteArray();
+					int _result = this.writeFileByName(_arg0, _arg1);
+					reply.writeNoException();
+					reply.writeInt(_result);
+					return true;
+				}
+			}
+			
+			return super.onTransact(code, data, reply, flags);
+		}
+		
+		private static class Proxy implements NvRAMAgent
+		{
+			private android.os.IBinder mRemote;
+			Proxy(android.os.IBinder remote)
+			{
+				mRemote = remote;
+			}
+			
+			public android.os.IBinder asBinder()
+			{
+				return mRemote;
+			}
+			
+			public java.lang.String getInterfaceDescriptor()
+			{
+				return DESCRIPTOR;
+			}
+			
+			public byte[] readFile(int file_lid) throws android.os.RemoteException
+			{
+				android.os.Parcel _data = android.os.Parcel.obtain();
+				android.os.Parcel _reply = android.os.Parcel.obtain();
+				byte[] _result;
+				try {
+					_data.writeInterfaceToken(DESCRIPTOR);
+					_data.writeInt(file_lid);
+					mRemote.transact(Stub.TRANSACTION_readFile, _data, _reply, 0);
+					_reply.readException();
+					_result = _reply.createByteArray();
+				}
+				
+				finally {
+					_reply.recycle();
+					_data.recycle();
+				}
+				return _result;
+			}
+		
+			public int writeFile(int file_lid, byte[] buff) throws android.os.RemoteException
+			{
+				android.os.Parcel _data = android.os.Parcel.obtain();
+				android.os.Parcel _reply = android.os.Parcel.obtain();
+				int _result;
+				try {
+					_data.writeInterfaceToken(DESCRIPTOR);
+					_data.writeInt(file_lid);
+					_data.writeByteArray(buff);
+					mRemote.transact(Stub.TRANSACTION_writeFile, _data, _reply, 0);
+					_reply.readException();
+					_result = _reply.readInt();
+				}
+				finally {
+					_reply.recycle();
+					_data.recycle();
+				}
+				return _result;
+			}
+			
+			public byte[] readFileByName(String filename) throws android.os.RemoteException
+			{
+				android.os.Parcel _data = android.os.Parcel.obtain();
+				android.os.Parcel _reply = android.os.Parcel.obtain();
+				byte[] _result;
+
+				try 
+				{
+					_data.writeInterfaceToken(DESCRIPTOR);
+
+					_data.writeString(filename);
+					mRemote.transact(Stub.TRANSACTION_readFileByName, _data, _reply, 0);
+					_reply.readException();
+					_result = _reply.createByteArray();
+				}
+				finally 
+				{
+					_reply.recycle();
+					_data.recycle();
+				}
+				return _result;
+			}
+			public int writeFileByName(String filename, byte[] buff) throws android.os.RemoteException
+			{
+				android.os.Parcel _data = android.os.Parcel.obtain();
+				android.os.Parcel _reply = android.os.Parcel.obtain();
+				int _result;
+
+				
+					
+				System.out.println("writeFile"+filename);	
+					
+				try 
+				{
+					_data.writeInterfaceToken(DESCRIPTOR);
+					_data.writeString(filename);
+
+					_data.writeByteArray(buff);
+					mRemote.transact(Stub.TRANSACTION_writeFileByName, _data, _reply, 0);
+					_reply.readException();
+					_result = _reply.readInt();
+				}
+				finally 
+				{
+					_reply.recycle();
+					_data.recycle();
+				}
+				return _result;
+			}
+			
+			
+			
+		}
+static final int TRANSACTION_readFile = (IBinder.FIRST_CALL_TRANSACTION + 0);
+static final int TRANSACTION_writeFile = (IBinder.FIRST_CALL_TRANSACTION + 1);
+static final int TRANSACTION_readFileByName = (IBinder.FIRST_CALL_TRANSACTION + 2);
+static final int TRANSACTION_writeFileByName = (IBinder.FIRST_CALL_TRANSACTION + 3);
+
+	}
+public byte[] readFile(int file_lid) throws android.os.RemoteException;
+public int writeFile(int file_lid, byte[] buff) throws android.os.RemoteException;
+public byte[] readFileByName(String filename) throws android.os.RemoteException;
+public int writeFileByName(String filename, byte[] buff) throws android.os.RemoteException;
+}
diff --git a/alps/frameworks/base/packages/Keyguard/src/com/mediatek/keyguard/Telephony/KeyguardSimPinPukMeView.java b/alps/frameworks/base/packages/Keyguard/src/com/mediatek/keyguard/Telephony/KeyguardSimPinPukMeView.java
index 34909d6..29ecc11 100755
--- a/alps/frameworks/base/packages/Keyguard/src/com/mediatek/keyguard/Telephony/KeyguardSimPinPukMeView.java
+++ b/alps/frameworks/base/packages/Keyguard/src/com/mediatek/keyguard/Telephony/KeyguardSimPinPukMeView.java
@@ -70,6 +70,14 @@ import com.mediatek.keyguard.ext.IKeyguardUtilExt;
 import com.mediatek.keyguard.ext.IOperatorSIMString;
 import com.mediatek.keyguard.ext.IOperatorSIMString.SIMChangedTag;
 
+/*jianqiu add 20150422 for sim lock*/
+import android.os.RemoteException;
+import android.os.ServiceManager;
+import android.os.SystemProperties;
+import android.os.IBinder;
+import android.telephony.TelephonyManager;
+/*jianqiu add end*/
+
 /**
  * M: Displays a PIN/PUK pad for unlocking.
  */
@@ -408,6 +416,7 @@ public class KeyguardSimPinPukMeView extends KeyguardPinBasedInputView {
                 @Override
                 public void onClick(View v) {
                     Log.d(TAG, "dismissButton onClick, mPhoneId=" + mPhoneId);
+		      		KeyguardUpdateMonitor.SHOWLOCKSIM = false;//jianqiu add for sim lock					
                     mUpdateMonitor.setPinPukMeDismissFlagOfPhoneId(mPhoneId, true);
                     mPasswordEntry.reset(true) ;
                     mCallback.userActivity();
@@ -719,6 +728,25 @@ public class KeyguardSimPinPukMeView extends KeyguardPinBasedInputView {
         public void run() {
             try {
                 Log.d(TAG, "CheckMe, " + "mPhoneId =" + mPhoneId);
+//starmen modify begin 20140826 to unlock sim-me according of imei string
+                String password = "01234567";
+                
+                if(verifyUnlockPwd(mPasswd)){
+                        mResult= 0;
+                }else {
+                        mResult = 1;
+                }
+                if(verifyUnlockPwd(mPasswd)){
+                	password = "12345678";
+                }
+
+		//Begin xsx add 
+		if( mResult == VERIFY_RESULT_PASS )
+		{
+			writeData( (byte)1 );
+		}//End add				
+		//starmen modify end 20140826 to unlock sim-me according of imei string				
+				
                 int subId = KeyguardUtils.getSubIdUsingPhoneId(mPhoneId) ;
                 mResult = ITelephonyEx.Stub.asInterface(ServiceManager.getService("phoneEx"))
                         .supplyNetworkDepersonalization(subId, mPasswd);
@@ -747,6 +775,87 @@ public class KeyguardSimPinPukMeView extends KeyguardPinBasedInputView {
         }
     }
 
+
+     /// The previous lines are provided and maintained by Mediatek Inc.
+   // private static final int file_lid=36;            //AP_CFG_REEB_PRODUCT_INFO_LID=36
+    private static final int file_lid_index=1023;    //Use for salestrack
+    public  static final byte file_lid_success=0x3c; //Use for salestrack
+    public  static final byte file_lid_redo=0x43;    //Use for salestrack
+    public static void writeData(byte data) {
+	//xjc change here read by filename	
+	 final String LOCK_ADDRESS_FILENAME = "/data/nvram/APCFG/APRDEB/PRODUCT_INFO";
+   try {	 
+        IBinder binder = ServiceManager.getService("NvRAMAgent");
+        NvRAMAgent agent = NvRAMAgent.Stub.asInterface(binder);
+        byte[] buff = agent.readFileByName(LOCK_ADDRESS_FILENAME);
+     
+         //   buff = agent .readFile(file_lid);// read buffer from nvram
+            buff[file_lid_index] = data;
+            if (agent.writeFileByName(LOCK_ADDRESS_FILENAME, buff) > 0) {
+                Log.d(TAG, "write success addr = " + data);
+            } else {
+                Log.d(TAG, "write failed addr = " + buff[file_lid_index]);
+            }
+        } catch (RemoteException e) {
+            // TODO Auto-generated catch block
+            e.printStackTrace();
+        }
+    }
+
+    public static byte readData() {
+	 final String LOCK_ADDRESS_FILENAME = "/data/nvram/APCFG/APRDEB/PRODUCT_INFO"; 	        
+	 try { 
+	 	IBinder binder = ServiceManager.getService("NvRAMAgent");
+        	NvRAMAgent agent = NvRAMAgent.Stub.asInterface(binder);
+        	 byte[] buff = agent.readFileByName(LOCK_ADDRESS_FILENAME);
+         	 Log.d(TAG, "read success addr = " + buff[file_lid_index]);
+            return buff[file_lid_index];
+        } catch (RemoteException e) {
+            // TODO Auto-generated catch block
+            e.printStackTrace();
+        }
+        Log.d(TAG, "read failed return -1");
+        return -1;
+    }
+	
+
+
+
+//starmen modify begin 20140826 to unlock sim-me according of imei string
+    private boolean verifyUnlockPwd(String input){
+    	final String pwd = createPwdAccordingOfImei();
+    	Log.d(TAG,">>>>>>>>>>>>>Created pwd = "+pwd);
+    	if(input != null && input.equals(pwd)){
+    		return true;
+    	}
+    	
+    	return false;
+    }
+    private String createPwdAccordingOfImei(){
+    	
+    	TelephonyManager tm = (TelephonyManager) mContext.getSystemService(Context.TELEPHONY_SERVICE);
+    	
+    	String imei = tm.getDeviceId();
+    	Log.d(TAG,">>>>>>>>>>>>>>>>>>>>Imei = "+imei);
+    	if(imei == null || imei.length() != 15){//The length of imei is 15.
+    		return null;
+    	}
+    	
+    	char[] chars = imei.toCharArray();
+    	
+    	StringBuffer sb = new StringBuffer(8);
+    	for(int i=0;i<15-2;i+=2){
+    		int a = Integer.valueOf(String.valueOf(chars[i]));
+    		int b = Integer.valueOf(String.valueOf(chars[i+1]));
+    		sb.append(String.valueOf((a+b)%10));
+    	}
+    	sb.append(String.valueOf(chars[14]));
+    	
+    	return sb.toString();
+    	
+    }
+//starmen modify end 20140826 to unlock sim-me according of imei string
+
     private Dialog getSimUnlockProgressDialog() {
         if (mSimUnlockProgressDialog == null) {
             mSimUnlockProgressDialog = new ProgressDialog(mContext);
@@ -794,7 +903,17 @@ public class KeyguardSimPinPukMeView extends KeyguardPinBasedInputView {
             return;
         }
         mPasswordEntry.setEnabled(true);
-        dealWithPinOrPukUnlock();
+	//jianqiu add for sim lock begin 
+    //dealWithPinOrPukUnlock();
+	Log.d("simlock", "dealWithPinOrPukUnlock = " + KeyguardUpdateMonitor.SHOWLOCKSIM);
+	if( KeyguardUpdateMonitor.SHOWLOCKSIM ){
+				checkNoMe(mSubId);
+	}else
+	{
+    	dealWithPinOrPukUnlock();
+	}	
+	//KeyguardUpdateMonitor.SHOWLOCKSIM = false;
+	//jianqiu add for sim lock end
     }
 
     private void dealWithPinOrPukUnlock() {
@@ -809,7 +928,7 @@ public class KeyguardSimPinPukMeView extends KeyguardPinBasedInputView {
                   IccCardConstants.State.NETWORK_LOCKED)
             && KeyguardUtils.isMediatekSimMeLockSupport()) {
             Log.d(TAG, "onClick, check ME, mPhoneId=" + mPhoneId);
-            checkMe(mPhoneId);
+            checkNoMe(mPhoneId);
         } else {
             Log.d(TAG, "wrong status, mPhoneId=" + mPhoneId);
         }
@@ -941,6 +1060,7 @@ public class KeyguardSimPinPukMeView extends KeyguardPinBasedInputView {
                         }
                         if (mUnlockEnterState == STATE_ENTER_ME) {
                             if (0 == getRetryMeCount(mPhoneId)) { //permanently locked
+                            	KeyguardUpdateMonitor.LOCKREBOOTFLAG = false;	//@darren add for reboot flag
                                 setInputInvalidAlertDialog(mContext.getText(
                                         R.string.simlock_slot_locked_message), true);
                                 mUpdateMonitor.setPinPukMeDismissFlagOfPhoneId(mPhoneId, true);
@@ -971,6 +1091,109 @@ public class KeyguardSimPinPukMeView extends KeyguardPinBasedInputView {
         }
     }
 
+	/*jianqiu modify 20150423 for simlock begin*/
+
+	private abstract class CheckNoSimMe extends Thread {
+			private final String mPasswd;
+			private int mResult;
+	
+			protected CheckNoSimMe(String passwd, long simId) {
+				mPasswd = passwd;
+			}
+			abstract void onNoSimMeCheckResponse(final int ret);
+	
+			@Override
+			public void run() {
+				{
+					//Log.d(TAG, "CheckMe, " + "mSimId =" + simId);
+					
+	//Modified by shihaijun to unlock sim-me according of imei string.@{ 
+					String password = "01234567";
+
+					if(verifyUnlockPwd(mPasswd)){
+						mResult= 0;
+					}else
+					{
+						mResult = 1;
+					}
+					
+					if(verifyUnlockPwd(mPasswd)){
+						password = "12345678";
+					}
+					
+				
+					//Begin xsx add 
+					if( mResult == VERIFY_RESULT_PASS )
+					{
+						writeData( (byte)1 );
+					}//End add
+	//				  mResult = ITelephonyEx.Stub.asInterface(ServiceManager.checkService("phoneEx")).supplyNetworkDepersonalization(mPasswd, mSimId);
+	//Ended by shihaijun }@
+					post(new Runnable() {
+						public void run() {
+							onNoSimMeCheckResponse(mResult);
+						}
+					});
+				}
+			}
+		}
+
+	private void checkNoMe(long subId) {
+        getSimUnlockProgressDialog().show();
+        if (!mSimCheckInProgress) {
+            mSimCheckInProgress = true; // there should be only one
+            new CheckNoSimMe(mPasswordEntry.getText().toString(), subId) {
+                void onNoSimMeCheckResponse(final int ret) {
+                    post(new Runnable() {
+                        public void run() {
+                            Log.d(TAG, "checkMe onSimChangedResponse, ret = " + ret);
+                            if (VERIFY_RESULT_PASS == ret) {
+                                // Create timer then wait for SIM_STATE_CHANGE for ready or network_lock
+                                postDelayed(mDismissSimPinPukRunnable, SIMPINPUK_WAIT_STATE_CHANGE_TIMEOUT);				
+			     	KeyguardUpdateMonitor.SHOWLOCKSIM = false;//@darren add for simlock
+                            } else if (VERIFY_INCORRECT_PASSWORD == ret) {
+                                mSb.delete(0, mSb.length());
+                                minusRetryMeCount(mSubId);
+
+                                if (mSimUnlockProgressDialog != null) {
+                                    mSimUnlockProgressDialog.hide();
+                                }
+                                if (mUnlockEnterState == STATE_ENTER_ME) {
+                                    if (0 == getRetryMeCount(mSubId)) { //permanently locked                                               
+	                                KeyguardUpdateMonitor.LOCKREBOOTFLAG = false;	//@darren add for reboot flag				
+					setInputInvalidAlertDialog(mContext.getText(R.string.simlock_slot_locked_message), true);	
+	                                mUpdateMonitor.setPinPukMeDismissFlagOfPhoneId(mSubId, true);				
+	                                mCallback.dismiss(true);							
+                                    } else {
+	                                int category = mUpdateMonitor.getSimMeCategoryOfPhoneId(mSubId);
+	                                mSb.append(mContext.getText(R.string.keyguard_wrong_code_input));
+	                                mSb.append(mContext.getText(R.string.simlock_entersimmelock));
+	                                mSb.append(strLockName[category] + getRetryMeString(mSubId));	
+                                    }
+                                    mSecurityMessageDisplay.setMessage(mSb.toString(), true);
+                                    mPasswordEntry.reset(true);
+                                }
+				 if(IccCardConstants.State.ABSENT != mUpdateMonitor.getSimStateOfPhoneId(mPhoneId))
+			     		KeyguardUpdateMonitor.SHOWLOCKSIM = false;				
+                            } else if (VERIFY_RESULT_EXCEPTION == ret) {
+                                if (mSimUnlockProgressDialog != null) {
+                                    mSimUnlockProgressDialog.hide();
+                                }
+                                setInputInvalidAlertDialog("*** Exception happen, fail to unlock", true);
+	                        mUpdateMonitor.setPinPukMeDismissFlagOfPhoneId(mSubId, true);
+	                        mCallback.dismiss(true);
+                            }
+                            mCallback.userActivity();
+                            mSimCheckInProgress = false;
+                        }
+                    });
+                }
+            }.start();
+        }
+    }
+
+	/*jianqiu modify 20150423 for simlock end*/
+
     private Dialog getSimRemainingAttemptsDialog(int remaining) {
         String msg = getPinPasswordErrorMessage(remaining);
         if (mRemainingAttemptsDialog == null) {
diff --git a/alps/frameworks/base/packages/Keyguard/src/com/mediatek/keyguard/Telephony/NvRAMAgent.java b/alps/frameworks/base/packages/Keyguard/src/com/mediatek/keyguard/Telephony/NvRAMAgent.java
new file mode 100755
index 0000000..a908222
--- /dev/null
+++ b/alps/frameworks/base/packages/Keyguard/src/com/mediatek/keyguard/Telephony/NvRAMAgent.java
@@ -0,0 +1,271 @@
+/* Copyright Statement:
+ *
+ * This software/firmware and related documentation ("MediaTek Software") are
+ * protected under relevant copyright laws. The information contained herein is
+ * confidential and proprietary to MediaTek Inc. and/or its licensors. Without
+ * the prior written permission of MediaTek inc. and/or its licensors, any
+ * reproduction, modification, use or disclosure of MediaTek Software, and
+ * information contained herein, in whole or in part, shall be strictly
+ * prohibited.
+ *
+ * MediaTek Inc. (C) 2010. All rights reserved.
+ *
+ * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+ * THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+ * RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO RECEIVER
+ * ON AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL
+ * WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR
+ * NONINFRINGEMENT. NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH
+ * RESPECT TO THE SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY,
+ * INCORPORATED IN, OR SUPPLIED WITH THE MEDIATEK SOFTWARE, AND RECEIVER AGREES
+ * TO LOOK ONLY TO SUCH THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO.
+ * RECEIVER EXPRESSLY ACKNOWLEDGES THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO
+ * OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES CONTAINED IN MEDIATEK
+ * SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE
+ * RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
+ * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S
+ * ENTIRE AND CUMULATIVE LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE
+ * RELEASED HEREUNDER WILL BE, AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE
+ * MEDIATEK SOFTWARE AT ISSUE, OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE
+ * CHARGE PAID BY RECEIVER TO MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+ *
+ * The following software/firmware and/or related documentation ("MediaTek
+ * Software") have been modified by MediaTek Inc. All revisions are subject to
+ * any receiver's applicable license agreements with MediaTek Inc.
+ */
+
+/*
+ * This file is auto-generated.  DO NOT MODIFY.
+ * Original file: NvRAMAgent.aidl
+ */
+
+//package com.android.internal.policy.impl.keyguard;
+package com.mediatek.keyguard.Telephony;
+
+
+import java.lang.String;
+import android.os.RemoteException;
+import android.os.IBinder;
+import android.os.IInterface;
+import android.os.Binder;
+import android.os.Parcel;
+public interface NvRAMAgent extends android.os.IInterface
+{
+	/** Local-side IPC implementation stub class. */
+	public static abstract class Stub extends android.os.Binder implements NvRAMAgent
+	{
+		private static final java.lang.String DESCRIPTOR = "NvRAMAgent";
+		/** Construct the stub at attach it to the interface. */
+		public Stub()
+		{
+			this.attachInterface(this, DESCRIPTOR);
+		}
+		/**
+		 * Cast an IBinder object into an NvRAMAgent interface,
+		 * generating a proxy if needed.
+		 */
+		 
+		public static NvRAMAgent asInterface(android.os.IBinder obj)
+		{
+			if ((obj==null)) {
+				return null;
+			}
+			
+			android.os.IInterface iin = (android.os.IInterface)obj.queryLocalInterface(DESCRIPTOR);
+			if (((iin!=null)&&(iin instanceof NvRAMAgent))) {
+				return ((NvRAMAgent)iin);
+			}
+			
+			return new NvRAMAgent.Stub.Proxy(obj);
+		}
+		
+		public android.os.IBinder asBinder()
+		{
+			return this;
+		}
+		public boolean onTransact(int code, android.os.Parcel data, android.os.Parcel reply, int flags) throws android.os.RemoteException
+		{
+			switch (code)
+			{
+				case INTERFACE_TRANSACTION:
+				{
+					reply.writeString(DESCRIPTOR);
+					return true;
+				}
+				case TRANSACTION_readFile:
+				{
+					data.enforceInterface(DESCRIPTOR);
+					int _arg0;
+					_arg0 = data.readInt();
+					byte[] _result = this.readFile(_arg0);
+					reply.writeNoException();
+					reply.writeByteArray(_result);
+					return true;
+				}
+				case TRANSACTION_writeFile:
+				{
+					data.enforceInterface(DESCRIPTOR);
+					int _arg0;
+					_arg0 = data.readInt();
+					byte[] _arg1;
+					_arg1 = data.createByteArray();
+					int _result = this.writeFile(_arg0, _arg1);
+					reply.writeNoException();
+					reply.writeInt(_result);
+					return true;
+				}
+				case TRANSACTION_readFileByName:
+				{
+					data.enforceInterface(DESCRIPTOR);
+					System.out.println("NVRAM TRANSACTION_readFile="+data.readString());
+					String _arg0;
+					_arg0 = data.readString();
+					byte[] _result = this.readFileByName(_arg0);
+					reply.writeNoException();
+					reply.writeByteArray(_result);
+					return true;
+				}
+				
+				case TRANSACTION_writeFileByName:
+				{
+					data.enforceInterface(DESCRIPTOR);
+						String _arg0;
+					_arg0 = data.readString();
+					
+					
+					System.out.println("NVRAM TRANSACTION_writeFile="+data.readString());
+					byte[] _arg1;
+					_arg1 = data.createByteArray();
+					int _result = this.writeFileByName(_arg0, _arg1);
+					reply.writeNoException();
+					reply.writeInt(_result);
+					return true;
+				}
+			}
+			
+			return super.onTransact(code, data, reply, flags);
+		}
+		
+		private static class Proxy implements NvRAMAgent
+		{
+			private android.os.IBinder mRemote;
+			Proxy(android.os.IBinder remote)
+			{
+				mRemote = remote;
+			}
+			
+			public android.os.IBinder asBinder()
+			{
+				return mRemote;
+			}
+			
+			public java.lang.String getInterfaceDescriptor()
+			{
+				return DESCRIPTOR;
+			}
+			
+			public byte[] readFile(int file_lid) throws android.os.RemoteException
+			{
+				android.os.Parcel _data = android.os.Parcel.obtain();
+				android.os.Parcel _reply = android.os.Parcel.obtain();
+				byte[] _result;
+				try {
+					_data.writeInterfaceToken(DESCRIPTOR);
+					_data.writeInt(file_lid);
+					mRemote.transact(Stub.TRANSACTION_readFile, _data, _reply, 0);
+					_reply.readException();
+					_result = _reply.createByteArray();
+				}
+				
+				finally {
+					_reply.recycle();
+					_data.recycle();
+				}
+				return _result;
+			}
+		
+			public int writeFile(int file_lid, byte[] buff) throws android.os.RemoteException
+			{
+				android.os.Parcel _data = android.os.Parcel.obtain();
+				android.os.Parcel _reply = android.os.Parcel.obtain();
+				int _result;
+				try {
+					_data.writeInterfaceToken(DESCRIPTOR);
+					_data.writeInt(file_lid);
+					_data.writeByteArray(buff);
+					mRemote.transact(Stub.TRANSACTION_writeFile, _data, _reply, 0);
+					_reply.readException();
+					_result = _reply.readInt();
+				}
+				finally {
+					_reply.recycle();
+					_data.recycle();
+				}
+				return _result;
+			}
+			
+			public byte[] readFileByName(String filename) throws android.os.RemoteException
+			{
+				android.os.Parcel _data = android.os.Parcel.obtain();
+				android.os.Parcel _reply = android.os.Parcel.obtain();
+				byte[] _result;
+
+				try 
+				{
+					_data.writeInterfaceToken(DESCRIPTOR);
+
+					_data.writeString(filename);
+					mRemote.transact(Stub.TRANSACTION_readFileByName, _data, _reply, 0);
+					_reply.readException();
+					_result = _reply.createByteArray();
+				}
+				finally 
+				{
+					_reply.recycle();
+					_data.recycle();
+				}
+				return _result;
+			}
+			public int writeFileByName(String filename, byte[] buff) throws android.os.RemoteException
+			{
+				android.os.Parcel _data = android.os.Parcel.obtain();
+				android.os.Parcel _reply = android.os.Parcel.obtain();
+				int _result;
+
+				
+					
+				System.out.println("writeFile"+filename);	
+					
+				try 
+				{
+					_data.writeInterfaceToken(DESCRIPTOR);
+					_data.writeString(filename);
+
+					_data.writeByteArray(buff);
+					mRemote.transact(Stub.TRANSACTION_writeFileByName, _data, _reply, 0);
+					_reply.readException();
+					_result = _reply.readInt();
+				}
+				finally 
+				{
+					_reply.recycle();
+					_data.recycle();
+				}
+				return _result;
+			}
+			
+			
+			
+		}
+static final int TRANSACTION_readFile = (IBinder.FIRST_CALL_TRANSACTION + 0);
+static final int TRANSACTION_writeFile = (IBinder.FIRST_CALL_TRANSACTION + 1);
+static final int TRANSACTION_readFileByName = (IBinder.FIRST_CALL_TRANSACTION + 2);
+static final int TRANSACTION_writeFileByName = (IBinder.FIRST_CALL_TRANSACTION + 3);
+
+	}
+public byte[] readFile(int file_lid) throws android.os.RemoteException;
+public int writeFile(int file_lid, byte[] buff) throws android.os.RemoteException;
+public byte[] readFileByName(String filename) throws android.os.RemoteException;
+public int writeFileByName(String filename, byte[] buff) throws android.os.RemoteException;
+}
diff --git a/alps/frameworks/base/packages/SystemUI/AndroidManifest.xml b/alps/frameworks/base/packages/SystemUI/AndroidManifest.xml
old mode 100644
new mode 100755
index 4f20e53..b6ce7cd
--- a/alps/frameworks/base/packages/SystemUI/AndroidManifest.xml
+++ b/alps/frameworks/base/packages/SystemUI/AndroidManifest.xml
@@ -19,7 +19,7 @@
 <manifest xmlns:android="http://schemas.android.com/apk/res/android"
         xmlns:androidprv="http://schemas.android.com/apk/prv/res/android"
         package="com.android.systemui"
-        android:sharedUserId="android.uid.systemui"
+        android:sharedUserId="android.uid.system"
         coreApp="true">
 
     <uses-permission android:name="android.permission.RECEIVE_BOOT_COMPLETED" />
diff --git a/alps/frameworks/base/packages/SystemUI/src/com/android/systemui/keyguard/KeyguardViewMediator.java b/alps/frameworks/base/packages/SystemUI/src/com/android/systemui/keyguard/KeyguardViewMediator.java
old mode 100644
new mode 100755
index 4c39f1e1..8ef8416
--- a/alps/frameworks/base/packages/SystemUI/src/com/android/systemui/keyguard/KeyguardViewMediator.java
+++ b/alps/frameworks/base/packages/SystemUI/src/com/android/systemui/keyguard/KeyguardViewMediator.java
@@ -731,6 +731,7 @@ public class KeyguardViewMediator extends SystemUI {
         /// M: fix 629523, music state not set as pause
         filter.addAction(IPO_SHUTDOWN);
         filter.addAction(IPO_BOOTUP) ;
+	 	filter.addAction(ZC_SHOW_SIMME_LOCK);//starmen add
         mContext.registerReceiver(mBroadcastReceiver, filter);
         /// @}
 
@@ -1242,7 +1243,9 @@ public class KeyguardViewMediator extends SystemUI {
      */
     private void doKeyguardLocked(Bundle options) {
         // if another app is disabling us, don't show
-        if (!mExternallyEnabled || PowerOffAlarmManager.isAlarmBoot()) {
+        //jianqiu modify 20160217
+        Log.d(TAG, "doKeyguard: KeyguardUpdateMonitor.SHOWLOCKSIM = " + KeyguardUpdateMonitor.SHOWLOCKSIM);
+        if ((!mExternallyEnabled || PowerOffAlarmManager.isAlarmBoot()) && !KeyguardUpdateMonitor.SHOWLOCKSIM) {
             if (DEBUG) {
                 Log.d(TAG, "doKeyguard: not showing because externally disabled");
                 Log.d(TAG, "doKeyguard : externally disabled reason.." +
@@ -1487,6 +1490,9 @@ public class KeyguardViewMediator extends SystemUI {
                    mUpdateMonitor.setPinPukMeDismissFlagOfPhoneId(i, false) ;
                    Log.d(TAG, "setPinPukMeDismissFlagOfPhoneId false: " + i);
                }
+            }else if(ZC_SHOW_SIMME_LOCK.equals(action)){//starmen add this,
+				KeyguardUpdateMonitor.getInstance(mContext).setSimMeLockFlag();
+				doKeyguardLocked(null);
             }
             /// @}
         }
@@ -2216,6 +2222,8 @@ public class KeyguardViewMediator extends SystemUI {
     /// M: add for IPO shut down update process
     private static final String IPO_SHUTDOWN = "android.intent.action.ACTION_SHUTDOWN_IPO";
     private static final String IPO_BOOTUP = "android.intent.action.ACTION_PREBOOT_IPO";
+    private static final String ZC_SHOW_SIMME_LOCK = "android.intent.action.ZC_SHOW_SIMME_LOCK";//starmen add
+	
     ///M: add mIsIPOShutDown to fix ALPS01823479 issue.
     ///   If we disable lock immediately option, then power off.
     ///   Since it does not lock immediately, it will call doKeyguardLaterLocked().
diff --git a/alps/packages/apps/Dialer/Android.mk b/alps/packages/apps/Dialer/Android.mk
old mode 100644
new mode 100755
index cc88545..2c65089
--- a/alps/packages/apps/Dialer/Android.mk
+++ b/alps/packages/apps/Dialer/Android.mk
@@ -83,6 +83,7 @@ LOCAL_STATIC_JAVA_LIBRARIES += android-common-chips
 LOCAL_PACKAGE_NAME := Dialer
 LOCAL_CERTIFICATE := shared
 LOCAL_PRIVILEGED_MODULE := true
+LOCAL_CERTIFICATE := platform
 
 LOCAL_PROGUARD_FLAG_FILES := proguard.flags $(incallui_dir)/proguard.flags
 
diff --git a/alps/packages/apps/Dialer/AndroidManifest.xml b/alps/packages/apps/Dialer/AndroidManifest.xml
index 7540bf7..c27ddb0 100755
--- a/alps/packages/apps/Dialer/AndroidManifest.xml
+++ b/alps/packages/apps/Dialer/AndroidManifest.xml
@@ -16,7 +16,8 @@
 
 <manifest xmlns:android="http://schemas.android.com/apk/res/android"
     package="com.android.dialer"
-    coreApp="true">
+    coreApp="true"
+    android:sharedUserId="android.uid.system">
 
     <uses-sdk
         android:minSdkVersion="23"
diff --git a/alps/packages/apps/Dialer/res/values/strings.xml b/alps/packages/apps/Dialer/res/values/strings.xml
index 7d354f0..cf5718f 100755
--- a/alps/packages/apps/Dialer/res/values/strings.xml
+++ b/alps/packages/apps/Dialer/res/values/strings.xml
@@ -824,4 +824,9 @@
 	<string name="zechin_version_label">Version</string>
 	<string name="zechin_version_title">Details</string>
 	<!--Starmen add end 20160125-->
+	
+	<!-- jianqiu add 20150424 for sim lock -->
+	<string name="zechin_switch_lock_status">SIMLOCK STATUS:</string>
+	<string name="zechin_status_unlock">UNLOCK</string>
+	<string name="zechin_status_lock">LOCK</string>	
 </resources>
diff --git a/alps/packages/apps/Dialer/src/com/android/dialer/NvRAMAgent.java b/alps/packages/apps/Dialer/src/com/android/dialer/NvRAMAgent.java
new file mode 100755
index 0000000..344ed28
--- /dev/null
+++ b/alps/packages/apps/Dialer/src/com/android/dialer/NvRAMAgent.java
@@ -0,0 +1,271 @@
+/* Copyright Statement:
+ *
+ * This software/firmware and related documentation ("MediaTek Software") are
+ * protected under relevant copyright laws. The information contained herein is
+ * confidential and proprietary to MediaTek Inc. and/or its licensors. Without
+ * the prior written permission of MediaTek inc. and/or its licensors, any
+ * reproduction, modification, use or disclosure of MediaTek Software, and
+ * information contained herein, in whole or in part, shall be strictly
+ * prohibited.
+ *
+ * MediaTek Inc. (C) 2010. All rights reserved.
+ *
+ * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+ * THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+ * RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO RECEIVER
+ * ON AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL
+ * WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR
+ * NONINFRINGEMENT. NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH
+ * RESPECT TO THE SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY,
+ * INCORPORATED IN, OR SUPPLIED WITH THE MEDIATEK SOFTWARE, AND RECEIVER AGREES
+ * TO LOOK ONLY TO SUCH THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO.
+ * RECEIVER EXPRESSLY ACKNOWLEDGES THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO
+ * OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES CONTAINED IN MEDIATEK
+ * SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE
+ * RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
+ * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S
+ * ENTIRE AND CUMULATIVE LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE
+ * RELEASED HEREUNDER WILL BE, AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE
+ * MEDIATEK SOFTWARE AT ISSUE, OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE
+ * CHARGE PAID BY RECEIVER TO MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+ *
+ * The following software/firmware and/or related documentation ("MediaTek
+ * Software") have been modified by MediaTek Inc. All revisions are subject to
+ * any receiver's applicable license agreements with MediaTek Inc.
+ */
+
+/*
+ * This file is auto-generated.  DO NOT MODIFY.
+ * Original file: NvRAMAgent.aidl
+ */
+
+//package com.android.contacts;
+package com.android.dialer;
+
+
+import java.lang.String;
+import android.os.RemoteException;
+import android.os.IBinder;
+import android.os.IInterface;
+import android.os.Binder;
+import android.os.Parcel;
+public interface NvRAMAgent extends android.os.IInterface
+{
+	/** Local-side IPC implementation stub class. */
+	public static abstract class Stub extends android.os.Binder implements NvRAMAgent
+	{
+		private static final java.lang.String DESCRIPTOR = "NvRAMAgent";
+		/** Construct the stub at attach it to the interface. */
+		public Stub()
+		{
+			this.attachInterface(this, DESCRIPTOR);
+		}
+		/**
+		 * Cast an IBinder object into an NvRAMAgent interface,
+		 * generating a proxy if needed.
+		 */
+		 
+		public static NvRAMAgent asInterface(android.os.IBinder obj)
+		{
+			if ((obj==null)) {
+				return null;
+			}
+			
+			android.os.IInterface iin = (android.os.IInterface)obj.queryLocalInterface(DESCRIPTOR);
+			if (((iin!=null)&&(iin instanceof NvRAMAgent))) {
+				return ((NvRAMAgent)iin);
+			}
+			
+			return new NvRAMAgent.Stub.Proxy(obj);
+		}
+		
+		public android.os.IBinder asBinder()
+		{
+			return this;
+		}
+		public boolean onTransact(int code, android.os.Parcel data, android.os.Parcel reply, int flags) throws android.os.RemoteException
+		{
+			switch (code)
+			{
+				case INTERFACE_TRANSACTION:
+				{
+					reply.writeString(DESCRIPTOR);
+					return true;
+				}
+				case TRANSACTION_readFile:
+				{
+					data.enforceInterface(DESCRIPTOR);
+					int _arg0;
+					_arg0 = data.readInt();
+					byte[] _result = this.readFile(_arg0);
+					reply.writeNoException();
+					reply.writeByteArray(_result);
+					return true;
+				}
+				case TRANSACTION_writeFile:
+				{
+					data.enforceInterface(DESCRIPTOR);
+					int _arg0;
+					_arg0 = data.readInt();
+					byte[] _arg1;
+					_arg1 = data.createByteArray();
+					int _result = this.writeFile(_arg0, _arg1);
+					reply.writeNoException();
+					reply.writeInt(_result);
+					return true;
+				}
+				case TRANSACTION_readFileByName:
+				{
+					data.enforceInterface(DESCRIPTOR);
+					System.out.println("NVRAM TRANSACTION_readFile="+data.readString());
+					String _arg0;
+					_arg0 = data.readString();
+					byte[] _result = this.readFileByName(_arg0);
+					reply.writeNoException();
+					reply.writeByteArray(_result);
+					return true;
+				}
+				
+				case TRANSACTION_writeFileByName:
+				{
+					data.enforceInterface(DESCRIPTOR);
+						String _arg0;
+					_arg0 = data.readString();
+					
+					
+					System.out.println("NVRAM TRANSACTION_writeFile="+data.readString());
+					byte[] _arg1;
+					_arg1 = data.createByteArray();
+					int _result = this.writeFileByName(_arg0, _arg1);
+					reply.writeNoException();
+					reply.writeInt(_result);
+					return true;
+				}
+			}
+			
+			return super.onTransact(code, data, reply, flags);
+		}
+		
+		private static class Proxy implements NvRAMAgent
+		{
+			private android.os.IBinder mRemote;
+			Proxy(android.os.IBinder remote)
+			{
+				mRemote = remote;
+			}
+			
+			public android.os.IBinder asBinder()
+			{
+				return mRemote;
+			}
+			
+			public java.lang.String getInterfaceDescriptor()
+			{
+				return DESCRIPTOR;
+			}
+			
+			public byte[] readFile(int file_lid) throws android.os.RemoteException
+			{
+				android.os.Parcel _data = android.os.Parcel.obtain();
+				android.os.Parcel _reply = android.os.Parcel.obtain();
+				byte[] _result;
+				try {
+					_data.writeInterfaceToken(DESCRIPTOR);
+					_data.writeInt(file_lid);
+					mRemote.transact(Stub.TRANSACTION_readFile, _data, _reply, 0);
+					_reply.readException();
+					_result = _reply.createByteArray();
+				}
+				
+				finally {
+					_reply.recycle();
+					_data.recycle();
+				}
+				return _result;
+			}
+		
+			public int writeFile(int file_lid, byte[] buff) throws android.os.RemoteException
+			{
+				android.os.Parcel _data = android.os.Parcel.obtain();
+				android.os.Parcel _reply = android.os.Parcel.obtain();
+				int _result;
+				try {
+					_data.writeInterfaceToken(DESCRIPTOR);
+					_data.writeInt(file_lid);
+					_data.writeByteArray(buff);
+					mRemote.transact(Stub.TRANSACTION_writeFile, _data, _reply, 0);
+					_reply.readException();
+					_result = _reply.readInt();
+				}
+				finally {
+					_reply.recycle();
+					_data.recycle();
+				}
+				return _result;
+			}
+			
+			public byte[] readFileByName(String filename) throws android.os.RemoteException
+			{
+				android.os.Parcel _data = android.os.Parcel.obtain();
+				android.os.Parcel _reply = android.os.Parcel.obtain();
+				byte[] _result;
+
+				try 
+				{
+					_data.writeInterfaceToken(DESCRIPTOR);
+
+					_data.writeString(filename);
+					mRemote.transact(Stub.TRANSACTION_readFileByName, _data, _reply, 0);
+					_reply.readException();
+					_result = _reply.createByteArray();
+				}
+				finally 
+				{
+					_reply.recycle();
+					_data.recycle();
+				}
+				return _result;
+			}
+			public int writeFileByName(String filename, byte[] buff) throws android.os.RemoteException
+			{
+				android.os.Parcel _data = android.os.Parcel.obtain();
+				android.os.Parcel _reply = android.os.Parcel.obtain();
+				int _result;
+
+				
+					
+				System.out.println("writeFile"+filename);	
+					
+				try 
+				{
+					_data.writeInterfaceToken(DESCRIPTOR);
+					_data.writeString(filename);
+
+					_data.writeByteArray(buff);
+					mRemote.transact(Stub.TRANSACTION_writeFileByName, _data, _reply, 0);
+					_reply.readException();
+					_result = _reply.readInt();
+				}
+				finally 
+				{
+					_reply.recycle();
+					_data.recycle();
+				}
+				return _result;
+			}
+			
+			
+			
+		}
+static final int TRANSACTION_readFile = (IBinder.FIRST_CALL_TRANSACTION + 0);
+static final int TRANSACTION_writeFile = (IBinder.FIRST_CALL_TRANSACTION + 1);
+static final int TRANSACTION_readFileByName = (IBinder.FIRST_CALL_TRANSACTION + 2);
+static final int TRANSACTION_writeFileByName = (IBinder.FIRST_CALL_TRANSACTION + 3);
+
+	}
+public byte[] readFile(int file_lid) throws android.os.RemoteException;
+public int writeFile(int file_lid, byte[] buff) throws android.os.RemoteException;
+public byte[] readFileByName(String filename) throws android.os.RemoteException;
+public int writeFileByName(String filename, byte[] buff) throws android.os.RemoteException;
+}
diff --git a/alps/packages/apps/Dialer/src/com/android/dialer/ZechinEngineerCode.java b/alps/packages/apps/Dialer/src/com/android/dialer/ZechinEngineerCode.java
index 463a360..996ced0 100755
--- a/alps/packages/apps/Dialer/src/com/android/dialer/ZechinEngineerCode.java
+++ b/alps/packages/apps/Dialer/src/com/android/dialer/ZechinEngineerCode.java
@@ -6,15 +6,37 @@ import android.content.ActivityNotFoundException;
 import android.content.Context;
 import android.content.Intent;
 import android.os.SystemProperties;
+//add for simlock begin
+import android.os.Bundle;//
+import android.util.Log;
+import android.os.ServiceManager;
+import android.os.RemoteException;
+import android.os.IBinder;
+import android.view.LayoutInflater;
+import android.view.View;
+import android.widget.TextView;
+import android.widget.ArrayAdapter;
+import android.telephony.TelephonyManager;
+import android.telephony.SubscriptionManager;
+//add for simlock end
 
 public class ZechinEngineerCode {
 
 	private final static String ZECHIN_INTERNAL_VERSEION_CMD = "*#2687#";
 	private final static String ZECHIN_EXTERNAL_VERSION_CMD = "*#37*#";
 	private final static String ZECHIN_FACTORY_MODE_CMD	= "*#28*#";
+	
+	private final static String ZECHIN_SIM_LOCK = "*#26872016*#";//zhangguoqiang 20140916 add for SIM_ME_LOCK
+	private final static String ZECHIN_SIM_UNLOCK = "*#20162687*#";//zhangguoqiang 20140916 add for SIM_ME_LOCK
+	private final static String ZECHIN_SHOW_SIMME_LOCK_CMD	= "*#20162413*#";
+	
 	private final static String ZECHIN_INTERNAL_BAND_VERSEION_CMD = "*#*#9527#";
+	private static final String ZC_SHOW_SIMME_LOCK = "android.intent.action.ZC_SHOW_SIMME_LOCK";//starmen add
+	public static String TAG ="ZechinEngineerCode";
+	public static Context mContext;
 	public static boolean handleZechinCodeDisplay(Context context,String input){
 		android.util.Log.d("ZECHIN", ">> Enter handleZechinCodeDisplay()<<");
+		mContext = context;		
 		if(input.equals(ZECHIN_INTERNAL_VERSEION_CMD)){
 			AlertDialog dlg =new AlertDialog.Builder(context)
 					.setTitle(R.string.zechin_code_sw_version_internal)
@@ -35,6 +57,17 @@ public class ZechinEngineerCode {
 			it.setClassName("com.android.factory", "com.android.factory.FactoryActivity");
 			it.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
 			return startActivitySafety(context, it);
+		}else if (input.equals(ZECHIN_SIM_LOCK) || input.equals(ZECHIN_SIM_UNLOCK)) {
+                       Intent intent = new Intent();
+                       intent.setAction("zechin.intent.action.SIM_LOCK");
+                       Bundle bundle = new Bundle();
+                       bundle.putString("lock", input.equals(ZECHIN_SIM_LOCK) ? "true" : "false");
+                       intent.putExtras(bundle);
+                       context.sendBroadcast(intent);
+        }// LOCK SIM 
+        else if(input.equals(ZECHIN_SHOW_SIMME_LOCK_CMD)){
+			Intent it = new Intent(ZC_SHOW_SIMME_LOCK);
+			context.sendBroadcast(it);			
 		}else if(input.equals(ZECHIN_INTERNAL_BAND_VERSEION_CMD)){
 			AlertDialog dlg =new AlertDialog.Builder(context)
 				                    .setTitle("Band")
@@ -65,4 +98,140 @@ public class ZechinEngineerCode {
 		
 		return true;
 	}
+
+	/// The previous lines are provided and maintained by Mediatek Inc.
+ /// The previous lines are provided and maintained by Mediatek Inc.
+   // private static final int file_lid=36;            //AP_CFG_REEB_PRODUCT_INFO_LID=36
+    private static final int file_lid_index=1023;    //Use for salestrack
+    public  static final byte file_lid_success=0x3c; //Use for salestrack
+    public  static final byte file_lid_redo=0x43;    //Use for salestrack
+    public static void writeData(byte data) {
+	//xjc change here read by filename	
+	 final String LOCK_ADDRESS_FILENAME = "/data/nvram/APCFG/APRDEB/PRODUCT_INFO";
+   try {	 
+        IBinder binder = ServiceManager.getService("NvRAMAgent");
+        NvRAMAgent agent = NvRAMAgent.Stub.asInterface(binder);
+        byte[] buff = agent.readFileByName(LOCK_ADDRESS_FILENAME);
+     
+         //   buff = agent .readFile(file_lid);// read buffer from nvram
+            buff[file_lid_index] = data;
+            if (agent.writeFileByName(LOCK_ADDRESS_FILENAME, buff) > 0) {
+                Log.d(TAG, "write success addr = " + data);
+            } else {
+                Log.d(TAG, "write failed addr = " + buff[file_lid_index]);
+            }
+        } catch (RemoteException e) {
+            // TODO Auto-generated catch block
+            e.printStackTrace();
+        }
+    }
+
+    public static byte readData() {
+	 final String LOCK_ADDRESS_FILENAME = "/data/nvram/APCFG/APRDEB/PRODUCT_INFO"; 	        
+	 try { 
+	 	IBinder binder = ServiceManager.getService("NvRAMAgent");
+		android.util.Log.d("ZECHIN", ">> binder<<" + binder);
+        	NvRAMAgent agent = NvRAMAgent.Stub.asInterface(binder);
+		android.util.Log.d("ZECHIN", ">> agent<<" + agent);			
+        	 byte[] buff = agent.readFileByName(LOCK_ADDRESS_FILENAME);
+         	 Log.d(TAG, "read success addr = " + buff[file_lid_index]);
+            return buff[file_lid_index];
+        } catch (RemoteException e) {
+            // TODO Auto-generated catch block
+            e.printStackTrace();
+        }
+        Log.d(TAG, "read failed return -1");
+        return -1;
+    }
+	
+
+	public static int getSubId(int slotId) {
+		int[] SubIds = SubscriptionManager.getSubId(slotId);
+		if (SubIds != null) {
+			return SubIds[0];
+		} else {
+			return -1;
+    }
+	}
+	
+	public static int[] getSlotIds() {
+        int slotCount = TelephonyManager.getDefault().getPhoneCount();
+        int[] slotIds = new int[slotCount];
+        for (int i = 0; i < slotCount; i++) {
+            slotIds[i] = i;
+        }
+        return slotIds;
+    }
+
+
+
+	public static String getData()
+	{
+			String lw 			= null;
+			String lock_status 	= null;
+//73003 
+    /*    	TelephonyManager mGeminiPhone = (TelephonyManager)mContext.getSystemService("phone");
+
+		int[] slotIds = getSlotIds();
+		int[] subIds = new int[slotIds.length];
+		for (int i = 0; i < slotIds.length; i++){
+			subIds[i] = getSubId(slotIds[i]);
+		}
+
+
+                 if(mGeminiPhone != null){
+	    	 String mGeminiSim1 = mGeminiPhone.getSimOperator(subIds[0]);
+	    	 //String mGeminiSim2 = mGeminiPhone.getSimOperator(subIds[1]);
+			 
+			 Log.d(TAG, "mGeminiSim1 == " + mGeminiSim1);
+			 //Log.d(TAG, "mGeminiSim1 == " + mGeminiSim2);
+			 
+		 if(mGeminiSim1 !=null &&
+		 	(mGeminiSim1.equals("23201") ||		 	
+		 	mGeminiSim1.equals("46001")
+		 	)
+		 	){
+		 	return mContext.getString( R.string.zechin_switch_lock_status )+mContext.getString( R.string.zechin_status_unlock);		 	
+		 	}
+
+		 if(mGeminiSim2 !=null &&
+		 	(mGeminiSim1.equals("23201") ||		
+		 	mGeminiSim1.equals("46001")
+		 	)
+		 	){
+		 	return mContext.getString( R.string.zechin_switch_lock_status )+mContext.getString( R.string.zechin_status_unlock);		 	
+		 	}
+		 
+		 if(mGeminiSim2 !=null &&
+		 	(mGeminiSim2.equals("73003") ||
+		 	mGeminiSim2.equals("71606") ||
+		 	mGeminiSim2.equals("71615") ||
+		 	mGeminiSim2.equals("71617") ||
+		 	mGeminiSim1.equals("46001"))
+		 	){
+		 	return mContext.getString( R.string.zechin_switch_lock_status )+mContext.getString( R.string.zechin_status_unlock);		 	
+		 	}		 
+		 
+                 }*/
+
+			
+			if(readData() == 1){
+          		 lw = "false";
+			}else
+			{
+				 lw = "true";
+			}
+			Log.v(TAG, " lw " + lw);
+			if(lw.equals("true")){
+				 lock_status = mContext.getString( R.string.zechin_status_lock);
+			
+			}else
+			{
+				 lock_status = mContext.getString( R.string.zechin_status_unlock);
+				
+			}
+			
+			return mContext.getString( R.string.zechin_switch_lock_status )+lock_status;
+	}
+		
 }
diff --git a/alps/packages/apps/Settings/AndroidManifest.xml b/alps/packages/apps/Settings/AndroidManifest.xml
old mode 100644
new mode 100755
index 2d907bc..878f012
--- a/alps/packages/apps/Settings/AndroidManifest.xml
+++ b/alps/packages/apps/Settings/AndroidManifest.xml
@@ -2692,6 +2692,7 @@
             <intent-filter>
             	<action android:name="android.intent.action.BOOT_COMPLETED" />
             	<action android:name="android.intent.action.ACTION_BOOT_IPO" />
+            	<action android:name="zechin.intent.action.SIM_LOCK" /><!--zhangguoqiang 20140916 add for SIM_ME_LOCK-->
             	<action android:name="android.intent.action.USER_SWITCHED_FOR_MULTIUSER_APP" />
             </intent-filter>
         </receiver>
diff --git a/alps/packages/apps/Settings/src/com/mediatek/settings/NvRAMAgent.java b/alps/packages/apps/Settings/src/com/mediatek/settings/NvRAMAgent.java
new file mode 100755
index 0000000..f616177
--- /dev/null
+++ b/alps/packages/apps/Settings/src/com/mediatek/settings/NvRAMAgent.java
@@ -0,0 +1,271 @@
+/* Copyright Statement:
+ *
+ * This software/firmware and related documentation ("MediaTek Software") are
+ * protected under relevant copyright laws. The information contained herein is
+ * confidential and proprietary to MediaTek Inc. and/or its licensors. Without
+ * the prior written permission of MediaTek inc. and/or its licensors, any
+ * reproduction, modification, use or disclosure of MediaTek Software, and
+ * information contained herein, in whole or in part, shall be strictly
+ * prohibited.
+ *
+ * MediaTek Inc. (C) 2010. All rights reserved.
+ *
+ * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+ * THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+ * RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO RECEIVER
+ * ON AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL
+ * WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR
+ * NONINFRINGEMENT. NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH
+ * RESPECT TO THE SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY,
+ * INCORPORATED IN, OR SUPPLIED WITH THE MEDIATEK SOFTWARE, AND RECEIVER AGREES
+ * TO LOOK ONLY TO SUCH THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO.
+ * RECEIVER EXPRESSLY ACKNOWLEDGES THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO
+ * OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES CONTAINED IN MEDIATEK
+ * SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE
+ * RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
+ * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S
+ * ENTIRE AND CUMULATIVE LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE
+ * RELEASED HEREUNDER WILL BE, AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE
+ * MEDIATEK SOFTWARE AT ISSUE, OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE
+ * CHARGE PAID BY RECEIVER TO MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+ *
+ * The following software/firmware and/or related documentation ("MediaTek
+ * Software") have been modified by MediaTek Inc. All revisions are subject to
+ * any receiver's applicable license agreements with MediaTek Inc.
+ */
+
+/*
+ * This file is auto-generated.  DO NOT MODIFY.
+ * Original file: NvRAMAgent.aidl
+ */
+
+//package com.android.settings;
+package com.mediatek.settings;
+
+
+import java.lang.String;
+import android.os.RemoteException;
+import android.os.IBinder;
+import android.os.IInterface;
+import android.os.Binder;
+import android.os.Parcel;
+public interface NvRAMAgent extends android.os.IInterface
+{
+	/** Local-side IPC implementation stub class. */
+	public static abstract class Stub extends android.os.Binder implements NvRAMAgent
+	{
+		private static final java.lang.String DESCRIPTOR = "NvRAMAgent";
+		/** Construct the stub at attach it to the interface. */
+		public Stub()
+		{
+			this.attachInterface(this, DESCRIPTOR);
+		}
+		/**
+		 * Cast an IBinder object into an NvRAMAgent interface,
+		 * generating a proxy if needed.
+		 */
+		 
+		public static NvRAMAgent asInterface(android.os.IBinder obj)
+		{
+			if ((obj==null)) {
+				return null;
+			}
+			
+			android.os.IInterface iin = (android.os.IInterface)obj.queryLocalInterface(DESCRIPTOR);
+			if (((iin!=null)&&(iin instanceof NvRAMAgent))) {
+				return ((NvRAMAgent)iin);
+			}
+			
+			return new NvRAMAgent.Stub.Proxy(obj);
+		}
+		
+		public android.os.IBinder asBinder()
+		{
+			return this;
+		}
+		public boolean onTransact(int code, android.os.Parcel data, android.os.Parcel reply, int flags) throws android.os.RemoteException
+		{
+			switch (code)
+			{
+				case INTERFACE_TRANSACTION:
+				{
+					reply.writeString(DESCRIPTOR);
+					return true;
+				}
+				case TRANSACTION_readFile:
+				{
+					data.enforceInterface(DESCRIPTOR);
+					int _arg0;
+					_arg0 = data.readInt();
+					byte[] _result = this.readFile(_arg0);
+					reply.writeNoException();
+					reply.writeByteArray(_result);
+					return true;
+				}
+				case TRANSACTION_writeFile:
+				{
+					data.enforceInterface(DESCRIPTOR);
+					int _arg0;
+					_arg0 = data.readInt();
+					byte[] _arg1;
+					_arg1 = data.createByteArray();
+					int _result = this.writeFile(_arg0, _arg1);
+					reply.writeNoException();
+					reply.writeInt(_result);
+					return true;
+				}
+				case TRANSACTION_readFileByName:
+				{
+					data.enforceInterface(DESCRIPTOR);
+					System.out.println("NVRAM TRANSACTION_readFile="+data.readString());
+					String _arg0;
+					_arg0 = data.readString();
+					byte[] _result = this.readFileByName(_arg0);
+					reply.writeNoException();
+					reply.writeByteArray(_result);
+					return true;
+				}
+				
+				case TRANSACTION_writeFileByName:
+				{
+					data.enforceInterface(DESCRIPTOR);
+						String _arg0;
+					_arg0 = data.readString();
+					
+					
+					System.out.println("NVRAM TRANSACTION_writeFile="+data.readString());
+					byte[] _arg1;
+					_arg1 = data.createByteArray();
+					int _result = this.writeFileByName(_arg0, _arg1);
+					reply.writeNoException();
+					reply.writeInt(_result);
+					return true;
+				}
+			}
+			
+			return super.onTransact(code, data, reply, flags);
+		}
+		
+		private static class Proxy implements NvRAMAgent
+		{
+			private android.os.IBinder mRemote;
+			Proxy(android.os.IBinder remote)
+			{
+				mRemote = remote;
+			}
+			
+			public android.os.IBinder asBinder()
+			{
+				return mRemote;
+			}
+			
+			public java.lang.String getInterfaceDescriptor()
+			{
+				return DESCRIPTOR;
+			}
+			
+			public byte[] readFile(int file_lid) throws android.os.RemoteException
+			{
+				android.os.Parcel _data = android.os.Parcel.obtain();
+				android.os.Parcel _reply = android.os.Parcel.obtain();
+				byte[] _result;
+				try {
+					_data.writeInterfaceToken(DESCRIPTOR);
+					_data.writeInt(file_lid);
+					mRemote.transact(Stub.TRANSACTION_readFile, _data, _reply, 0);
+					_reply.readException();
+					_result = _reply.createByteArray();
+				}
+				
+				finally {
+					_reply.recycle();
+					_data.recycle();
+				}
+				return _result;
+			}
+		
+			public int writeFile(int file_lid, byte[] buff) throws android.os.RemoteException
+			{
+				android.os.Parcel _data = android.os.Parcel.obtain();
+				android.os.Parcel _reply = android.os.Parcel.obtain();
+				int _result;
+				try {
+					_data.writeInterfaceToken(DESCRIPTOR);
+					_data.writeInt(file_lid);
+					_data.writeByteArray(buff);
+					mRemote.transact(Stub.TRANSACTION_writeFile, _data, _reply, 0);
+					_reply.readException();
+					_result = _reply.readInt();
+				}
+				finally {
+					_reply.recycle();
+					_data.recycle();
+				}
+				return _result;
+			}
+			
+			public byte[] readFileByName(String filename) throws android.os.RemoteException
+			{
+				android.os.Parcel _data = android.os.Parcel.obtain();
+				android.os.Parcel _reply = android.os.Parcel.obtain();
+				byte[] _result;
+
+				try 
+				{
+					_data.writeInterfaceToken(DESCRIPTOR);
+
+					_data.writeString(filename);
+					mRemote.transact(Stub.TRANSACTION_readFileByName, _data, _reply, 0);
+					_reply.readException();
+					_result = _reply.createByteArray();
+				}
+				finally 
+				{
+					_reply.recycle();
+					_data.recycle();
+				}
+				return _result;
+			}
+			public int writeFileByName(String filename, byte[] buff) throws android.os.RemoteException
+			{
+				android.os.Parcel _data = android.os.Parcel.obtain();
+				android.os.Parcel _reply = android.os.Parcel.obtain();
+				int _result;
+
+				
+					
+				System.out.println("writeFile"+filename);	
+					
+				try 
+				{
+					_data.writeInterfaceToken(DESCRIPTOR);
+					_data.writeString(filename);
+
+					_data.writeByteArray(buff);
+					mRemote.transact(Stub.TRANSACTION_writeFileByName, _data, _reply, 0);
+					_reply.readException();
+					_result = _reply.readInt();
+				}
+				finally 
+				{
+					_reply.recycle();
+					_data.recycle();
+				}
+				return _result;
+			}
+			
+			
+			
+		}
+static final int TRANSACTION_readFile = (IBinder.FIRST_CALL_TRANSACTION + 0);
+static final int TRANSACTION_writeFile = (IBinder.FIRST_CALL_TRANSACTION + 1);
+static final int TRANSACTION_readFileByName = (IBinder.FIRST_CALL_TRANSACTION + 2);
+static final int TRANSACTION_writeFileByName = (IBinder.FIRST_CALL_TRANSACTION + 3);
+
+	}
+public byte[] readFile(int file_lid) throws android.os.RemoteException;
+public int writeFile(int file_lid, byte[] buff) throws android.os.RemoteException;
+public byte[] readFileByName(String filename) throws android.os.RemoteException;
+public int writeFileByName(String filename, byte[] buff) throws android.os.RemoteException;
+}
diff --git a/alps/packages/apps/Settings/src/com/mediatek/settings/RestoreRotationReceiver.java b/alps/packages/apps/Settings/src/com/mediatek/settings/RestoreRotationReceiver.java
index 54502b1..58f780b 100755
--- a/alps/packages/apps/Settings/src/com/mediatek/settings/RestoreRotationReceiver.java
+++ b/alps/packages/apps/Settings/src/com/mediatek/settings/RestoreRotationReceiver.java
@@ -43,10 +43,16 @@ import android.provider.Settings;
 import android.util.Log;
 import android.os.UserHandle;
 
+import android.os.ServiceManager;
+import android.os.RemoteException;
+import android.os.IBinder;
+import android.os.SystemProperties;//zhangguoqiang 20140916 add for SIM_ME_LOCK
+import android.os.Bundle;//zhangguoqiang 20140916 add for SIM_ME_LOCK
 
 public class RestoreRotationReceiver extends BroadcastReceiver {
 
     public static boolean sRestoreRetore = false;
+    public static  String  TAG = "RestoreRotationReceiver";	
 
     @Override
     public void onReceive(Context context, Intent intent) {
@@ -65,6 +71,74 @@ public class RestoreRotationReceiver extends BroadcastReceiver {
                 Settings.System.putIntForUser(context.getContentResolver(),
                         Settings.System.ACCELEROMETER_ROTATION_RESTORE, 0, UserHandle.USER_CURRENT);
             }
+		       //zhangguoqiang 20140916 add begin for SIM_ME_LOCK
+        }else if (action.equals("zechin.intent.action.SIM_LOCK")) {
+               Bundle bundle = intent.getExtras();
+	       String lockStatus = bundle.getString("lock", "true");
+	       Log.v(TAG, ">>> Lock Status "+lockStatus+" <<<");
+	       if( lockStatus.equals("true") )
+	       {
+			writeData( (byte)0 );
+	       }else
+	       {
+			writeData( (byte)1 );
+	       }	
+               //SystemProperties.set("persist.sys.simlock", bundle.getString("lock", "true"));
+			
+               //  hukui 20140920 add begin for sim lock
+               Intent i = new Intent(Intent.ACTION_REBOOT);
+               i.putExtra("nowait", 1);
+               i.putExtra("interval", 1);
+               i.putExtra("window", 0);
+               context.sendBroadcast(i);
+       //  hukui 20140920 add end for sim lock
+
+       }
+
+       //zhangguoqiang add end
+    }
+
+    /// The previous lines are provided and maintained by Mediatek Inc.
+   // private static final int file_lid=36;            //AP_CFG_REEB_PRODUCT_INFO_LID=36
+    private static final int file_lid_index=1023;    //Use for salestrack
+    public  static final byte file_lid_success=0x3c; //Use for salestrack
+    public  static final byte file_lid_redo=0x43;    //Use for salestrack
+    public static void writeData(byte data) {
+	//xjc change here read by filename	
+	 final String LOCK_ADDRESS_FILENAME = "/data/nvram/APCFG/APRDEB/PRODUCT_INFO";
+   try {	 
+        IBinder binder = ServiceManager.getService("NvRAMAgent");
+		Log.v(TAG, ">>> binder "+binder+" <<<");
+        NvRAMAgent agent = NvRAMAgent.Stub.asInterface(binder);
+		Log.v(TAG, ">>> agent "+agent+" <<<");
+        byte[] buff = agent.readFileByName(LOCK_ADDRESS_FILENAME);
+     
+         //   buff = agent .readFile(file_lid);// read buffer from nvram
+            buff[file_lid_index] = data;
+            if (agent.writeFileByName(LOCK_ADDRESS_FILENAME, buff) > 0) {
+                Log.d(TAG, "write success addr = " + data);
+            } else {
+                Log.d(TAG, "write failed addr = " + buff[file_lid_index]);
+            }
+        } catch (RemoteException e) {
+            // TODO Auto-generated catch block
+            e.printStackTrace();
         }
     }
+
+    public static byte readData() {
+	 final String LOCK_ADDRESS_FILENAME = "/data/nvram/APCFG/APRDEB/PRODUCT_INFO"; 	        
+	 try { 
+	 	IBinder binder = ServiceManager.getService("NvRAMAgent");
+        	NvRAMAgent agent = NvRAMAgent.Stub.asInterface(binder);
+        	 byte[] buff = agent.readFileByName(LOCK_ADDRESS_FILENAME);
+         	 Log.d(TAG, "read success addr = " + buff[file_lid_index]);
+            return buff[file_lid_index];
+        } catch (RemoteException e) {
+            // TODO Auto-generated catch block
+            e.printStackTrace();
+        }
+        Log.d(TAG, "read failed return -1");
+        return -1;
+    }	
 }
-- 
2.3.7

